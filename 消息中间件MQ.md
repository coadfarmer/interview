### 为什么使用MQ？MQ的优点

- 异步处理 - 相比于传统的串行、并行方式，提高了系统吞吐量。
- 应用解耦 - 系统间通过消息通信，不用关心其他系统的处理。
- 流量削峰 - 可以通过消息队列长度控制请求量；可以缓解短时间内的高并发请求。
- 日志处理 - 解决大量日志传输
- 消息通讯 - 消息队列一般都内置了高效的通讯机制，因此在一些需要点对点通信的场景中可以用到

### MQ的缺点

- 系统可用性降低

  如果消息队列出问题，系统也可能随之一起出问题

- 系统复杂度提高

  加入了消息队列，要多考虑很多方面的问题，比如：一致性问题、如何保证消息不被重复消费、如何保证消息可靠性传输等。因此，需要考虑的东西更多，复杂性增大。

- **一致性问题**

  消费者没有正确消费信息可能导致的数据不一致。

### 五种常见的消息中间件对比

| 对比方向 | 概要                                                         |
| -------- | ------------------------------------------------------------ |
| 吞吐量   | 万级的 ActiveMQ 和 RabbitMQ 的吞吐量（ActiveMQ 的性能最差）要比 十万级甚至是百万级的 RocketMQ 和 Kafka 低一个数量级。 |
| 可用性   | 都可以实现高可用。ActiveMQ 和 RabbitMQ 都是基于主从架构实现高可用性。RocketMQ 基于分布式架构。 kafka 也是分布式的，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用 |
| 时效性   | RabbitMQ 基于 erlang 开发，所以并发能力很强，性能极其好，延时很低，达到微秒级。其他三个都是 ms 级。 |
| 功能支持 | 除了 Kafka，其他三个功能都较为完备。 Kafka 功能较为简单，主要支持简单的 MQ 功能，在大数据领域的实时计算以及日志采集被大规模使用，是事实上的标准 |
| 消息丢失 | ActiveMQ 和 RabbitMQ 丢失的可能性非常低， RocketMQ 和 Kafka 理论上不会丢失。 |

### RabbitMQ特点

- **可靠性：** RabbitMQ使用一些机制来保证消息的可靠性，如持久化、传输确认及发布确认等。
- **灵活的路由：** 在消息进入队列之前，通过交换器来路由消息。对于典型的路由功能，RabbitMQ
  己经提供了一些内置的交换器来实现。针对更复杂的路由功能，可以将多个交换器绑定在一起，也可以通过插件机制来实现自己的交换器。这个后面会在我们讲 RabbitMQ 核心概念的时候详细介绍到。
- **扩展性：** 多个RabbitMQ节点可以组成一个集群，也可以根据实际业务情况动态地扩展集群中节点。
- **高可用性：** 队列可以在集群中的机器上设置镜像，使得在部分节点出现问题的情况下队列仍然可用。
- **支持多种协议：** RabbitMQ 除了原生支持 AMQP 协议，还支持 STOMP、MQTT 等多种消息中间件协议。
- **多语言客户端：** RabbitMQ几乎支持所有常用语言，比如 Java、Python、Ruby、PHP、C#、JavaScript等。
- **易用的管理界面：** RabbitMQ提供了一个易用的用户界面，使得用户可以监控和管理消息、集群中的节点等。在安装 RabbitMQ 的时候会介绍到，安装好 RabbitMQ 就自带管理界面。
- **插件机制：** RabbitMQ 提供了许多插件，以实现从多方面进行扩展，当然也可以编写自己的插件。感觉这个有点类似 Dubbo 的 SPI机制。

### RabbitMQ的核心概念

- Block：消息队列服务器实体
- Exchange：消息交换机
- Queue：消息队列
- Binding：绑定，把Exchange和queue按照路由规则绑定起来
- Routing Key：路由关键字，exchange根据这个关键字进行消息投递
- VHost：可以理解为虚拟的broker

### RabbitMQ的几种交换机

1. **Direct Exchange 直连交换机**

   将消息鲁豫到BindingKey和RoutingKey相匹配的队列中

2. **Fanout Exchange 广播交换机**

3. **Topic Exchange 主题交换机**

   其实和DirectExchange类似，但它支持设置一些通配符，*号匹配一个单词，#号匹配多个单词

### 如何保证RabbitMQ消息可靠传输

消息丢失主要有三种情况

1. **生产者丢失消息**

   RabbitMQ提供transaction和confirm模式来确保生产者不丢失消息

    - transaction：开启事务，发送消息异常会回滚，但会影响性能
    - confirm（常用）：在该信道上发布的消息都会被指派一个唯一的ID，发送成功后RabbitMQ会发送一个ACK给生产者告知已经发送成功了；如果rabbitMQ没能处理该消息，则会发送一个Nack消息给你，你可以进行重试操作。

2. **消息队列丢失数据**

   消息持久化，具体操作是：

    1. 把queue的durable设为true
    2. 发送消息的时候将deliveryMode = 2

   注意：不应将所有的消息都持久化，否则会极大影响性能

3. **消费者丢失消息**

   一般是因为采用了自动确认消息模式，改为手动回复确认消息

