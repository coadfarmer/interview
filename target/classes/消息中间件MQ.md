### 为什么使用MQ？MQ的优点

- 异步处理 - 提高了系统吞吐量。
- 应用解耦 - 系统间通过消息通信，不用关心其他系统的处理。
- 流量削峰 - 可以通过消息队列长度控制请求量；可以缓解短时间内的高并发请求。
- 消息通讯 - 消息队列一般都内置了高效的通讯机制，因此在一些需要点对点通信的场景中可以用到

### MQ的缺点

- 系统可用性降低

  如果消息队列出问题，系统也可能随之一起出问题

- 系统复杂度提高

  加入了消息队列，要多考虑很多方面的问题，比如：一致性问题、如何保证消息不被重复消费、如何保证消息可靠性传输等。因此，需要考虑的东西更多，复杂性增大。

- 一致性问题

  消费者没有正确消费信息可能导致的数据不一致。

### 五种常见的消息中间件对比

|     特性     |                         ActiveMQ                         |                     RabbitMQ                     |                 RocketMQ                  |                Kafka                 |
| :----------: | :------------------------------------------------------: | :----------------------------------------------: | :---------------------------------------: | :----------------------------------: |
|   开发语言   |                           Java                           |                      Erlang                      |                   Java                    |                Scala                 |
|   协议支持   |                   AMQP、MQTT、STOMP等                    |               AMQP、STOMP、MQTT等                |            MQ 协议、支持 MQTT             |              Kafka协议               |
| 消息传输方式 |                     点对点、发布订阅                     |                 点对点、发布订阅                 |          点对点、发布订阅、广播           |               发布订阅               |
|   消息存储   | 基于 JDBC 的 JDBC 消息存储、KahaDB、JDBC master-slave 等 |     基于内存的 ETS 表和基于磁盘的 Mnesia 表      |       基于内存和磁盘的多种存储模式        |         基于磁盘的持久化存储         |
|  可靠性保证  |        提供消息持久化、消息事务等机制，可靠性较高        |    提供消息持久化、消息事务等机制，可靠性较高    |     提供多种存储模式，消息可靠性较高      | 提供消息持久化和备份机制，可靠性较高 |
|    吞吐量    |                           中等                           |                        高                        |                    高                     |                非常高                |
|    扩展性    |              支持集群和主从模式，扩展性较好              |          支持集群和主从模式，扩展性较好          |         支持集群模式，扩展性较好          |      支持集群模式，扩展性非常好      |
|   社区支持   |          Apache 社区的项目，拥有活跃的社区支持           |           社区活跃，有许多插件可供选择           | Apache 社区的顶级项目，拥有活跃的社区支持 |        社区活跃，生态系统庞大        |
|   商业支持   |              由于较早开发，商业支持较为成熟              | 由于开发语言特性和应用场景不同，商业支持相对较少 |    由于较早开发，商业支持相对较为成熟     |  由于应用场景不同，商业支持相对较多  |
|   应用场景   |         适用于吞吐量较小、对可靠性要求较高的场景         |             适用于对消息可靠性、延迟             |                                           |                                      |

### RabbitMQ特点

- **可靠性：** RabbitMQ使用一些机制来保证消息的可靠性，如持久化、传输确认及发布确认等。
- **扩展性：** 多个RabbitMQ节点可以组成一个集群，也可以根据实际业务情况动态地扩展集群中节点。
- **高可用性：** 队列可以在集群中的机器上设置镜像，使得在部分节点出现问题的情况下队列仍然可用。
- **多协议：** RabbitMQ 除了原生支持 AMQP 协议，还支持 STOMP、MQTT 等多种消息中间件协议。
- **多语言：** RabbitMQ几乎支持所有常用语言，比如 Java、Python、Ruby、PHP、C#、JavaScript等。
- **多插件：** RabbitMQ 提供了许多插件，以实现从多方面进行扩展，当然也可以编写自己的插件。感觉这个有点类似 Dubbo 的 SPI机制。
- **灵活的路由：** 在消息进入队列之前，通过交换器来路由消息。对于典型的路由功能，RabbitMQ
  己经提供了一些内置的交换器来实现。针对更复杂的路由功能，可以将多个交换器绑定在一起，也可以通过插件机制来实现自己的交换器。这个后面会在我们讲 RabbitMQ 核心概念的时候详细介绍到。
- **易用的管理界面：** RabbitMQ提供了一个易用的用户界面，使得用户可以监控和管理消息、集群中的节点等。在安装 RabbitMQ 的时候会介绍到，安装好 RabbitMQ 就自带管理界面。

### RabbitMQ的核心概念

- Block：消息队列服务器实体
- Exchange：消息交换机
- Queue：消息队列
- Binding：绑定，把Exchange和queue按照路由规则绑定起来
- Routing Key：路由关键字，exchange根据这个关键字进行消息投递
- VHost：可以理解为虚拟的broker

### RabbitMQ的几种交换机

1. **Direct Exchange 直连交换机**

   将消息路由到BindingKey和RoutingKey相匹配的队列中

2. **Fanout Exchange 广播交换机**

   把消息路由到与交换机绑定的所有队列中

3. **Topic Exchange 主题交换机**

   其实和DirectExchange类似，但它支持设置一些通配符，*号匹配一个单词，#号匹配多个单词

   ![img](https://www.rabbitmq.com/img/tutorials/python-five.png)

### 如何保证RabbitMQ消息可靠传输

消息丢失主要有三种情况

1. **生产者丢失消息**

   RabbitMQ提供transaction和confirm模式来确保生产者不丢失消息

    - transaction：开启事务，发送消息异常会回滚，但会影响性能
    - confirm（常用）：在该信道上发布的消息都会被指派一个唯一的ID，发送成功后RabbitMQ会发送一个ACK给生产者告知已经发送成功了；如果rabbitMQ没能处理该消息，则会发送一个Nack消息给你，你可以进行重试操作。

2. **消息队列丢失数据**

   消息持久化，具体操作是：

    1. 把queue的durable设为true
    2. 发送消息的时候将deliveryMode = 2

   注意：不应将所有的消息都持久化，否则会极大影响性能

3. **消费者丢失消息**

   一般是因为采用了自动确认消息模式，改为手动回复确认消息

